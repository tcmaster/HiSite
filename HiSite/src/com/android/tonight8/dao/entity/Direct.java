package com.android.tonight8.dao.entity;

import com.android.tonight8.dao.DaoSession;
import de.greenrobot.dao.DaoException;

import com.android.tonight8.dao.DirectDao;
import com.android.tonight8.dao.EventDao;
import com.android.tonight8.dao.OrgDao;
import com.android.tonight8.dao.SellerDao;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table DIRECT.
 */
public class Direct {

    private long id;
    private Long eventId;
    private Long orgId;
    private Long sellerId;
    private Integer commissionType;
    private Float commissionNumber;
    private Integer status;
    private String inviteTime;
    private String answerTime;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient DirectDao myDao;

    private Event event;
    private Long event__resolvedKey;

    private Org org;
    private Long org__resolvedKey;

    private Seller seller;
    private Long seller__resolvedKey;


    public Direct() {
    }

    public Direct(long id) {
        this.id = id;
    }

    public Direct(long id, Long eventId, Long orgId, Long sellerId, Integer commissionType, Float commissionNumber, Integer status, String inviteTime, String answerTime) {
        this.id = id;
        this.eventId = eventId;
        this.orgId = orgId;
        this.sellerId = sellerId;
        this.commissionType = commissionType;
        this.commissionNumber = commissionNumber;
        this.status = status;
        this.inviteTime = inviteTime;
        this.answerTime = answerTime;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getDirectDao() : null;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Long getEventId() {
        return eventId;
    }

    public void setEventId(Long eventId) {
        this.eventId = eventId;
    }

    public Long getOrgId() {
        return orgId;
    }

    public void setOrgId(Long orgId) {
        this.orgId = orgId;
    }

    public Long getSellerId() {
        return sellerId;
    }

    public void setSellerId(Long sellerId) {
        this.sellerId = sellerId;
    }

    public Integer getCommissionType() {
        return commissionType;
    }

    public void setCommissionType(Integer commissionType) {
        this.commissionType = commissionType;
    }

    public Float getCommissionNumber() {
        return commissionNumber;
    }

    public void setCommissionNumber(Float commissionNumber) {
        this.commissionNumber = commissionNumber;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public String getInviteTime() {
        return inviteTime;
    }

    public void setInviteTime(String inviteTime) {
        this.inviteTime = inviteTime;
    }

    public String getAnswerTime() {
        return answerTime;
    }

    public void setAnswerTime(String answerTime) {
        this.answerTime = answerTime;
    }

    /** To-one relationship, resolved on first access. */
    public Event getEvent() {
        Long __key = this.eventId;
        if (event__resolvedKey == null || !event__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            EventDao targetDao = daoSession.getEventDao();
            Event eventNew = targetDao.load(__key);
            synchronized (this) {
                event = eventNew;
            	event__resolvedKey = __key;
            }
        }
        return event;
    }

    public void setEvent(Event event) {
        synchronized (this) {
            this.event = event;
            eventId = event == null ? null : event.getId();
            event__resolvedKey = eventId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Org getOrg() {
        Long __key = this.orgId;
        if (org__resolvedKey == null || !org__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            OrgDao targetDao = daoSession.getOrgDao();
            Org orgNew = targetDao.load(__key);
            synchronized (this) {
                org = orgNew;
            	org__resolvedKey = __key;
            }
        }
        return org;
    }

    public void setOrg(Org org) {
        synchronized (this) {
            this.org = org;
            orgId = org == null ? null : org.getId();
            org__resolvedKey = orgId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Seller getSeller() {
        Long __key = this.sellerId;
        if (seller__resolvedKey == null || !seller__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SellerDao targetDao = daoSession.getSellerDao();
            Seller sellerNew = targetDao.load(__key);
            synchronized (this) {
                seller = sellerNew;
            	seller__resolvedKey = __key;
            }
        }
        return seller;
    }

    public void setSeller(Seller seller) {
        synchronized (this) {
            this.seller = seller;
            sellerId = seller == null ? null : seller.getId();
            seller__resolvedKey = sellerId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
